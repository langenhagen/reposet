#!/bin/bash
#
# Pulls the remote pull branches onto the local branches.
#
# author: andreasl

function show_usage {
    script_name="${0##*/}"

    msg="${script_name}\n"
    msg="${msg}Pulls the remote pull branches onto the local branches.\n"
    msg="${msg}Checks out the local default branches, calls \`git fetch --prune --tags\` and calls"
    msg="${msg} \`git pull --rebase\` from the default remote pull branch onto the local default"
    msg="${msg} branch in each repo in the given reposets.\n"
    msg="${msg}Aborts and reports as soon as an error occurs.\n"
    msg="${msg}If no errors are catched, runs \`git status --short --untracked-files\` for each"
    msg="${msg} repo afterwards.\n"
    msg="${msg}\n"
    msg="${msg}Usage:\n"
    msg="${msg}  ${script_name} [<reposet>...]\n"
    msg="${msg}\n"
    msg="${msg}Examples:\n"
    msg="${msg}  ${script_name}                  # calls \`git pull --rebase\` on all repos in the default reposet\n"
    msg="${msg}  ${script_name} my               # calls \`git pull --rebase\` on all repos in the reposet \"my\"\n"
    msg="${msg}  ${script_name} my work          # calls \`git pull --rebase\` on all repos in the reposets \"my\" and \"work\"\n"
    msg="${msg}  ${script_name} -h               # prints the usage message\n"
    msg="${msg}  ${script_name} --help           # prints the usage message\n"
    printf "$msg"
}

while [ $# -gt 0 ] ; do
    case "$1" in
    -h|--help)
        show_usage
        exit 0
        ;;
    *) # reposet name / unknown option
        break
        ;;
    esac
    shift # past argument or value
done

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=src/reposet.inc.sh
source "${script_dir}/reposet.inc.sh"
load_reposets_or_die "$@"

for repo in "${_repos[@]}"; do
    set_common_repo_variables "$repo"
    n_current_repo++
    cd_to_repo_or_die 1
    print_current_repo_and_progress
    check_if_local_branch_exists_or_die 2
    checkout_local_branch_or_die 3

    if [ -z "$pull_remote" ] || [ -z "$pull_branch" ] ; then
        printf -- "${blue} Repo ${bblue}$repo_path${blue} is not set up for pulling.${n}\n"
        continue
    fi

    if ! git fetch --prune --tags "$pull_remote" "$pull_branch" ; then
        msg="Calling \`${rb}git fetch --prune --tags ${pull_remote} ${pull_branch}${r}\` on the"
        msg="${msg} repo ${rb}${repo_path}${r} failed."
        die "$msg" 4 "cd \"${repo_path}\""
    fi

    git pull --rebase "$pull_remote" "$pull_branch"
    code="$?"
    if [ "$code" != 0 ] ; then
        msg="Calling \`${rb}git pull --rebase ${pull_remote} ${pull_branch}${r}\` on the repo"
        msg="${msg} ${rb}${repo_path}${r} failed: "
        if [ "$code" == 1 ] ; then
            msg="${msg} Did not find this remote branch."
        elif [ "$code" == 128 ] ; then
            msg="${msg} Merge conflict."
        else
            msg="${msg} Unknown error."
        fi
        die "$msg" "$code" "cd \"${repo_path}\""
    fi
done

print_all_repos_status_or_die 5
